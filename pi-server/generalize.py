import copy

from difftree.nodes import *
from difftree.schema import *
from rules import *
import pandas as pd
from parse_sql.piparser import PIParser

def generate_new_node(text, parent, sibling, table, att, ctype, generalized_nodes ):
    """
    Generate the new nodes
    generalized_nodes: list, record the newly generated nodes, will be used to recover the tree
    """
    # the generalized node should have the same rule as its sibling node.
    # ANY
    # |  \  \
    # A   B   C
    # A is the sibling of B
    # generate the new node based on the node generated by query

    new_node = LiteralNode(sibling.rule, str(text), [])
    new_node.parent = parent
    new_node.crank = len(parent.children)
    new_node.typ = Type(EType.ADVANCED)
    new_node.typ.attr = att
    new_node.typ.table = table
    new_node.typ.ctype = ctype
    new_node.node_schema = sibling.node_schema
    parent.children.append(new_node)
    generalized_nodes.append(new_node)


def get_any_nodes(node,info,catalog):
    # get the ANYNode in the from_clause in the difftree
    chs = []
    if node.rule == "expr":
        info["expr"] = True
    if isinstance(node, ANYNode):
        # only get the any node in "expr"
        if info["expr"]:
            if type(node.node_schema) == TypeSchema and node.node_schema.type.type == EType.ADVANCED:
                for c in node.children:
                    if catalog.is_attribute(c.get_text()):
                        return
                    chs.append(node)
    for c in node.children:
        chs += get_any_nodes(c,info,catalog)
    if node.rule == "expr":
        info[node.rule] = False
    return chs



def generalize(difftrees, db, catalog, generalized_nodes):
    # set the limitation of the number of newly generated nodes
    limit = 100
    # get the roots of the difftrees
    new_trees = []
    for i in difftrees:
        new_trees.append(i.root)

    info = {}
    for i, t in enumerate(new_trees):
        info["expr"] = False
        # get the ANYNode in the where clause in the tree
        anys = get_any_nodes(t,info,catalog)

        if len(anys) == 0:
            continue


        # for a in anys_generalize:
        for a in anys:
            att = None
            table = None
            childrens = deepcopy(a.children)

            #Record the text of the nodes that have already existed in the tree, avoid adding it
            exists = set()
            for child in childrens:
                exists.add(child.get_text().strip())

            # generalize the ANY node
            for c in childrens:
                if c.typ is None:
                    continue

                # If the context of the node is in the same attribute of the same table as the previous node,
                # do not need to get the domain and generalize it again.
                # Otherwise, need to generalize
                if (att is None or att != c.typ.attr) or (table is None or table != c.typ.table):
                    att = c.typ.attr
                    table = c.typ.table
                    ctype = c.typ.ctype

                    #get the doamin of the node from database:
                    query = "select distinct({}) from {}".format(att, table)
                    data = db.execute(query)

                    #If the number of newly generated nodes is above the limitation, then do not generalize
                    if data.data.shape[0]>limit:
                        continue

                    # sort the data
                    data.data.sort_values(att, inplace=True)

                    for idx, dt in data.data.iterrows():

                        # format the node whose ctype is in EType.STRING, EType.GEOJSON, EType.TEMPORAL
                        # add the '' in the text
                        if ctype in [EType.STRING, EType.GEOJSON, EType.TEMPORAL]:
                            dt[att] = "'" + dt[att] + "'"

                        # if the value has been queried, the node has existed in the tree, then do not generalize
                        if str(dt[att]) in exists:
                            continue

                        # otherwise generalize the node
                        generate_new_node(str(dt[att]),a, c, table, att, ctype, generalized_nodes)

    return difftrees



